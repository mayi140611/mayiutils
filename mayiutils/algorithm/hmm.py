#!/usr/bin/python
# encoding: utf-8

"""
@author: Ian
@contact:yongguiluo@hotmail.com
@file: hmm.py
@time: 2019/3/7 11:46

隐马尔科夫模型
"""
import numpy as np


class HMM:
    """
    μ = （S,K,A,B,π）
    S为状态的集合；
    K为输出符号的集合；
    A：状态转移概率；
    B：符号发射概率
    π：初始状态的概率分布；
    hmm有3个问题
    1、已知π、A、B，和观察序列O1O2O3O4...Ot，求解观察序列发生的概率
        前向算法、后向算法
        思路：定义前向变量，总结递推公式、动态规划
    2、已知π、A、B，和观察序列O1O2O3O4...Ot，求解最优状态序列
        维特比算法
        思路：维特比变量
    3、参数估计问题：
    给定观察序列O，如何根据最大似然法求模型的参数值？
    即如何调节模型μ=（A,B,π）的参数，使得P(O|μ)最大？
    """
    @classmethod
    def forward(cls):
        """
        求解观察序列概率
            前向算法
        :return:
        """


if __name__ == '__main__':
    mode = 2
    if mode == 1:
        """
        体验HMM第一个基本问题前向算法或后向算法解法，计算本课程幻灯片第34页“掷骰子HMM”中出现可观测序列为“1635273524”的概率，可使用任何编程语言或手工计算
        μ = （S,K,A,B,π）
    
        S为状态的集合{正方体，四面体，八面体}；
        K为输出符号的集合{1,2,3,4,5,6,7,8}；
        A为状态转移概率
        
            1/3 1/3 1/3
            1/3 1/3 1/3
            1/3 1/3 1/3
        B为符号发射概率
        
            1/6 1/4 1/8
            1/6 1/4 1/8
            1/6 1/4 1/8
            1/6 1/4 1/8
            1/6 0   1/8
            1/6 0   1/8
            0   0   1/8
            0   0   1/8
        
        π为初始状态的概率分布{1/3 1/3 1/3}
        """
        A = np.ones(9).reshape([3,3])/3
        B = np.array([[1/6,1/4,1/8],
                    [1/6,1/4,1/8],
                    [1/6,1/4,1/8],
                    [1/6,1/4,1/8],
                    [1/6,0,1/8],
                    [1/6,0,1/8],
                    [0,0,1/8],
                    [0,0,1/8]])

        Pi = np.ones(3)/3
        #1635273524
        O = [1,6,3,5,2,7,3,5,2,4]
        #正方体0，四面体1，八面体2
        a = np.zeros([10,3])
        count = 0
        for i in O:
            if count == 0:
                #第一步：初始化。第一个状态为1
                a[count,] = Pi * B[i-1,]
            else:
                #第二步：归纳计算
                a[count,] = np.dot(a[count-1,],A) * B[i-1,]
            count += 1

        print(a)
        P = np.sum(a[9,])
        print('“掷骰子HMM”中出现可观测序列为“1635273524”的概率:', P)
    elif mode == 2:
        """
        在上周作业的基础上，体验HMM第二个基本问题的维特比算法，
        计算上周幻灯片第34页“掷骰子HMM”中可观测序列为“1635273524”，
        反求出最大可能的隐藏状态序列，可使用任何编程语言或手工计算    
        
        """
        A = np.ones(9).reshape([3, 3]) / 3
        B = np.array([[1 / 6, 1 / 4, 1 / 8],
                      [1 / 6, 1 / 4, 1 / 8],
                      [1 / 6, 1 / 4, 1 / 8],
                      [1 / 6, 1 / 4, 1 / 8],
                      [1 / 6, 0, 1 / 8],
                      [1 / 6, 0, 1 / 8],
                      [0, 0, 1 / 8],
                      [0, 0, 1 / 8]])
        Pi = np.ones(3) / 3
        # 1635273524
        O = [1, 6, 3, 5, 2, 7, 3, 5, 2, 4]
        Q = np.zeros(len(O), dtype=int)  # 最大可能的隐藏状态序列
        δ = np.zeros([len(O), 3])  # 维特比变量
        ψ = np.zeros([len(O), 3], dtype=int)
        count = 0
        for i in O:
            if count == 0:
                # 第一步：初始化。第一个状态为1
                δ[count,] = Pi * B[i - 1,]
            else:
                # 第二步：归纳计算
                δ[count,] = np.max(δ[count - 1,] * A, 1) * B[i - 1,]
                # ψ[count,] = np.argmax(δ[count-1,]* A,1) * B[i-1,]
                ψ[count,] = np.argmax(δ[count - 1,] * A, 1)
                count += 1

        # 终结
        QT = np.argmax(δ[len(O) - 1,])
        PQT = np.max(δ[len(O) - 1,])
        count = 0
        for i in range(len(Q)):
            if i == 0:
                Q[i] = QT
            else:
                Q[i] = ψ[len(O) - i, Q[i - 1]]
            count += 1
        print(δ, ψ)
        print("最大可能的隐藏状态序列", Q[::-1])
        # 正方体0，四面体1，八面体2